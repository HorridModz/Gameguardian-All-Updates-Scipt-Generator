--[[

All updates script template auto-generated by Gameguardian All Updates Script Generator
https://github.com/HorridModz/Gameguardian-All-Updates-Script-Generator

--]]

--[[

USAGE INSTRUCTIONS (see Github for more detailed instructions):

This generated template contains code to perform the search and load the target function. It provides the functions
`load_hex` (to load the bytes into Gameguardian's search results, just as a normal search for the function's hex would)
and `edit_hex` (to edit the results to your desired value). You can also use `load_offset`, which returns the function's
offset. To use these functions, call them at the end of your script:

- load_hex(NUMBER_OF_BYTES)
- edit_hex(HEX)
You do not need to call `load_hex` before `edit_hex`. They are independent of each other; calling `edit_hex` is
sufficient on its own.
- load_offset()
NOTE: This will return a table, not a single value. If multiple functions are found (the script is not able to narrow it
down to one result), all of the found offsets will be returned in a table. If you are doing something like hooking,
make sure to hook each of these offsets.

WARNING: Generated script templates **will** overwrite each other. If you want to use multiple of these templates in one
script, make sure that your script does what it needs to do with one function before you paste in the code for another,
or else the second function will overwrite the first's.

--]]


GROUP_SEARCH = "$GROUP_SEARCH$"
SINGLE_VALUE = "$SINGLE_VALUE$"
SINGLE_VALUE_TYPE = "$DATA_TYPE$"
OFFSET_FROM_START = "$OFFSET_FROM_START$" -- decimal value (can be 0)
LIB_NAME = "$LIB_NAME$"
ARCHITECTURE = "$ARCHITECTURE$" -- "32bit" or "64bit"
MAX_RESULTS = "$MAX_RESULTS$" -- Set to -1 to permit any number of results
SHOW_CHOICE_IF_TOO_MANY_RESULTS = "$SHOW_CHOICE_IF_TOO_MANY_RESULTS$" -- "true" or "false"
-- Auto Repair is not yet implemented! It should always be "false"
AUTO_REPAIR = "$AUTO_REPAIR$" -- "true" or "false"

function _error(message)
    print("Error: " .. message)
    gg.setVisible(true)
    os.exit()
end

function _validate_inputs()
    if GROUP_SEARCH == nil and SINGLE_VALUE == nil then
        _error("Either GROUP_SEARCH or SINGLE_VALUE must be provided - use one, and set the other to nil.")
    end
    if GROUP_SEARCH ~= nil and SINGLE_VALUE ~= nil then
        _error("GROUP_SEARCH and SINGLE_VALUE are mutually exclusive - use one, and set the other to nil.")
    end
    if SINGLE_VALUE ~= nil then
        if tonumber(SINGLE_VALUE) == nil then
            _error("SINGLE_VALUE must be a number")
        end
        SINGLE_VALUE = tonumber(SINGLE_VALUE)
        data_types = { qword = gg.TYPE_QWORD, dword = gg.TYPE_DWORD, word = gg.TYPE_WORD, byte = gg.TYPE_BYTE }
        found = false
        for data_type, gg_type in pairs(data_types) do
            if SINGLE_VALUE_TYPE:lower() == data_type then
                SINGLE_VALUE_TYPE = gg_type
                found = true
                break
            end
        end
        if found == false then
            _error("SINGLE_VALUE_TYPE must be 'qword', 'dword', 'word', or 'byte'")
        end
    end
    if ARCHITECTURE ~= "32bit" and ARCHITECTURE ~= "64bit" then
        _error("Invalid valid for ARCHITECTURE - " .. ARCHITECTURE .. " (must be \"32bit\" or \"64bit\").")
    end
    if tonumber(OFFSET_FROM_START) == nil or tonumber(OFFSET_FROM_START) ~= math.floor(OFFSET_FROM_START) then
        _error("OFFSET_FROM_START must be a valid integer (not " .. OFFSET_FROM_START .. ").")
    end
    if tonumber(MAX_RESULTS) == nil or tonumber(MAX_RESULTS) ~= math.floor(MAX_RESULTS) then
        _error("MAX_RESULTS must be a valid integer (not " .. MAX_RESULTS .. ").")
    end
    MAX_RESULTS = tonumber(MAX_RESULTS)
    if SHOW_CHOICE_IF_TOO_MANY_RESULTS == "true" then
        SHOW_CHOICE_IF_TOO_MANY_RESULTS = true
    elseif SHOW_CHOICE_IF_TOO_MANY_RESULTS == "false" then
        SHOW_CHOICE_IF_TOO_MANY_RESULTS = false
    else
        _error("SHOW_CHOICE_IF_TOO_MANY_RESULTS must be \"true\" or \"false\" (not " .. SHOW_CHOICE_IF_TOO_MANY_RESULTS .. ").")
    end
    if AUTO_REPAIR == "true" then
        AUTO_REPAIR = true
    elseif AUTO_REPAIR == "false" then
        AUTO_REPAIR = false
    else
        _error("AUTO_REPAIR must be \"true\" or \"false\" (not " .. AUTO_REPAIR .. ").")
    end
    if AUTO_REPAIR == true then
        _error("Auto Repair is not yet implemented. Set Auto Repair to \"false\" and retry.")
    end
end

_validate_inputs()

function _occurrences_of(s, pattern)
    return select(2, string.gsub(s, pattern, ""))
end

function _letter(s, i)
    return s:gsub(i, i)
end

function _load_hex_at_address(address, bytes)
    results = {}
    for i = 0, bytes - 1 do
        results[#results + 1] = { address = address + i, flags = gg.TYPE_BYTE }
    end
    gg.loadResults(results)
end

function search_and_get_function_addresses()
    ranges = gg.getRangesList(LIB_NAME)
    if ranges == {} then
        _error("Failed to find lib '" .. LIB_NAME .. "'. Is the game running?")
    end
    lib_start = ranges[1]["start"]
    lib_end = ranges[1]["end"]
    gg.clearResults()
    if GROUP_SEARCH ~= nil then
        VALUES_COUNT = _occurrences_of(GROUP_SEARCH, ";") + 1
        gg.searchNumber(GROUP_SEARCH, gg.TYPE_AUTO, false, gg.SIGN_EQUAL, lib_start, lib_end)
    else
        VALUES_COUNT = 1
        gg.searchNumber(SINGLE_VALUE, SINGLE_VALUE_TYPE, false, gg.SIGN_EQUAL, lib_start, lib_end)
    end
    local results = gg.getResults(gg.getResultsCount())
    local found_functions = #results / VALUES_COUNT
    if found_functions == 0 then
        _error("Found no results for group search (" .. GROUP_SEARCH .. "). The script must be updated.")
    end
    if MAX_RESULTS ~= -1 and found_functions > MAX_RESULTS then
        if SHOW_CHOICE_IF_TOO_MANY_RESULTS then
            confirm = gg.choice({ "Ignore (Recommended)", "Cancel" }, nil, "Warning:\nA lot of results (" .. found_functions .. ") were found." ..
                    "Editing lots of values may cause (usually harmless) glitches or crashes. Would you like to proceed?")
            if confirm == nil or confirm == 2 then
                -- User clicked cancel or "Cancel"
                gg.clearResults()
                print("Found too many results (" .. found_functions .. " total functions), when tolerance is set to a maximum of " .. MAX_RESULTS .. " functions.")
                gg.setVisible(true)
                os.exit()
            end
        else
            _error("Found too many results (" .. found_functions .. " total functions), when tolerance is set to a maximum of " .. MAX_RESULTS .. " functions.")
        end
    end
    local function_addresses = {}
    for i = 1, found_functions do
        function_addresses[#function_addresses + 1] = results[(i - 1) * VALUES_COUNT + 1].address
    end
    return function_addresses
end

function load_hex(bytes)
    if bytes == nil then
        _error("When using load_hex, supply a value for amount of bytes to load")
    end
    local results = {}
    local function_addresses = search_and_get_function_addresses()
    for i = 1, #function_addresses do
        _load_hex_at_address(function_addresses[i], bytes)
        local function_results = gg.getResults(gg.getResultsCount())
        for i2 = 1, #function_results do
            results[#results + 1] = function_results[i2]
        end
    end
    gg.loadResults(results)
end

function edit_hex(hex)
    if hex == nil then
        _error("When using edit_hex, supply a hex value to edit to")
    end
    hex = hex:gsub("%s+", "")
    if _letter(hex, 1) ~= "h" then
        hex = "h" .. hex
    end
    if hex == "h" then
        _error("Edit hex is blank")
    end
    local hex_length = #hex  - 1
    if hex_length % 2 ~= 0 then
        _error("Invalid edit hex")
    end
    local bytes = hex_length / 2
    load_hex(bytes)
    gg.getResults(gg.getResultsCount())
    gg.editAll(hex, gg.TYPE_BYTE)
end

function load_offset()
    local offsets = {}
    local function_addresses = search_and_get_function_addresses()
    ranges = gg.getRangesList(LIB_NAME)
    if ranges == {} then
        _error("Failed to find lib '" .. LIB_NAME .. "'. Is the game running?")
    end
    lib_start = ranges[1]["start"]
    for i = 1, #function_addresses do
        offsets[#offsets + 1] = function_addresses[i] - lib_start
    end
    return offsets
end
