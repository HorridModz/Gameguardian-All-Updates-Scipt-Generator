--[[

All updates script template auto-generated by Gameguardian All Updates Script Generator
https://github.com/HorridModz/Gameguardian-All-Updates-Script-Generator

--]]

--[[

USAGE INSTRUCTIONS (see Github for more detailed instructions):

This generated template contains code to perform the search and load the target function. It provides the functions
`load_hex` (to load the bytes into Gameguardian's search results, just as a normal search for the function's hex would)
and `edit_hex` (to edit the results to your desired value). You can also use `load_offset`, which returns the function's
offset. To use these functions, call them at the end of your script:

- load_hex(NUMBER_OF_BYTES)
- edit_hex(HEX)
You do not need to call `load_hex` before `edit_hex`. They are independent of each other; calling `edit_hex` is
sufficient on its own.
- load_offset()
NOTE: This will return a table, not a single value. If multiple functions are found (the script is not able to narrow it
down to one result), all of the found offsets will be returned in a table. If you are doing something like hooking,
make sure to hook each of these offsets.

WARNING: Generated script templates **will** overwrite each other. If you want to use multiple of these templates in one
script, make sure that your script does what it needs to do with one function before you paste in the code for another,
or else the second function will overwrite the first's.

--]]

GROUP_SEARCH="$GROUP_SEARCH$"SINGLE_VALUE="$SINGLE_VALUE$"SINGLE_VALUE_TYPE="$DATA_TYPE$"OFFSET_FROM_START="$OFFSET_FROM_START$"LIB_NAME="$LIB_NAME$"ARCHITECTURE="$ARCHITECTURE$"MAX_RESULTS="$MAX_RESULTS$"SHOW_CHOICE_IF_TOO_MANY_RESULTS="$SHOW_CHOICE_IF_TOO_MANY_RESULTS$"AUTO_REPAIR="$AUTO_REPAIR$"function _error(a)print("Error: "..a)gg.setVisible(true)os.exit()end;function _validate_inputs()if GROUP_SEARCH==nil and SINGLE_VALUE==nil then _error("Either GROUP_SEARCH or SINGLE_VALUE must be provided - use one, and set the other to nil.")end;if GROUP_SEARCH~=nil and SINGLE_VALUE~=nil then _error("GROUP_SEARCH and SINGLE_VALUE are mutually exclusive - use one, and set the other to nil.")end;if SINGLE_VALUE~=nil then if tonumber(SINGLE_VALUE)==nil then _error("SINGLE_VALUE must be a number")end;SINGLE_VALUE=tonumber(SINGLE_VALUE)data_types={qword=gg.TYPE_QWORD,dword=gg.TYPE_DWORD,word=gg.TYPE_WORD,byte=gg.TYPE_BYTE}found=false;for b,c in pairs(data_types)do if SINGLE_VALUE_TYPE:lower()==b then SINGLE_VALUE_TYPE=c;found=true;break end end;if found==false then _error("SINGLE_VALUE_TYPE must be 'qword', 'dword', 'word', or 'byte'")end end;if ARCHITECTURE~="32bit"and ARCHITECTURE~="64bit"then _error("Invalid valid for ARCHITECTURE - "..ARCHITECTURE.." (must be \"32bit\" or \"64bit\").")end;if tonumber(OFFSET_FROM_START)==nil or tonumber(OFFSET_FROM_START)~=math.floor(OFFSET_FROM_START)then _error("OFFSET_FROM_START must be a valid integer (not "..OFFSET_FROM_START..").")end;if tonumber(MAX_RESULTS)==nil or tonumber(MAX_RESULTS)~=math.floor(MAX_RESULTS)then _error("MAX_RESULTS must be a valid integer (not "..MAX_RESULTS..").")end;MAX_RESULTS=tonumber(MAX_RESULTS)if SHOW_CHOICE_IF_TOO_MANY_RESULTS=="true"then SHOW_CHOICE_IF_TOO_MANY_RESULTS=true elseif SHOW_CHOICE_IF_TOO_MANY_RESULTS=="false"then SHOW_CHOICE_IF_TOO_MANY_RESULTS=false else _error("SHOW_CHOICE_IF_TOO_MANY_RESULTS must be \"true\" or \"false\" (not "..SHOW_CHOICE_IF_TOO_MANY_RESULTS..").")end;if AUTO_REPAIR=="true"then AUTO_REPAIR=true elseif AUTO_REPAIR=="false"then AUTO_REPAIR=false else _error("AUTO_REPAIR must be \"true\" or \"false\" (not "..AUTO_REPAIR..").")end;if AUTO_REPAIR==true then _error("Auto Repair is not yet implemented. Set Auto Repair to \"false\" and retry.")end end;_validate_inputs()function _occurrences_of(d,e)return select(2,string.gsub(d,e,""))end;function _letter(d,f)return d:gsub(f,f)end;function _load_hex_at_address(g,h)results={}for f=0,h-1 do results[#results+1]={address=g+f,flags=gg.TYPE_BYTE}end;gg.loadResults(results)end;function search_and_get_function_addresses()ranges=gg.getRangesList(LIB_NAME)if ranges=={}then _error("Failed to find lib '"..LIB_NAME.."'. Is the game running?")end;lib_start=ranges[1]["start"]lib_end=ranges[1]["end"]gg.clearResults()if GROUP_SEARCH~=nil then VALUES_COUNT=_occurrences_of(GROUP_SEARCH,";")+1;gg.searchNumber(GROUP_SEARCH,gg.TYPE_AUTO,false,gg.SIGN_EQUAL,lib_start,lib_end)else VALUES_COUNT=1;gg.searchNumber(SINGLE_VALUE,SINGLE_VALUE_TYPE,false,gg.SIGN_EQUAL,lib_start,lib_end)end;local results=gg.getResults(gg.getResultsCount())local i=#results/VALUES_COUNT;if i==0 then _error("Found no results for group search ("..GROUP_SEARCH.."). The script must be updated.")end;if MAX_RESULTS~=-1 and i>MAX_RESULTS then if SHOW_CHOICE_IF_TOO_MANY_RESULTS then confirm=gg.choice({"Ignore (Recommended)","Cancel"},nil,"Warning:\nA lot of results ("..i..") were found.".."Editing lots of values may cause (usually harmless) glitches or crashes. Would you like to proceed?")if confirm==nil or confirm==2 then gg.clearResults()print("Found too many results ("..i.." total functions), when tolerance is set to a maximum of "..MAX_RESULTS.." functions.")gg.setVisible(true)os.exit()end else _error("Found too many results ("..i.." total functions), when tolerance is set to a maximum of "..MAX_RESULTS.." functions.")end end;local j={}for f=1,i do j[#j+1]=results[(f-1)*VALUES_COUNT+1].address end;return j end;function load_hex(h)if h==nil then _error("When using load_hex, supply a value for amount of bytes to load")end;local results={}local j=search_and_get_function_addresses()for f=1,#j do _load_hex_at_address(j[f],h)local k=gg.getResults(gg.getResultsCount())for l=1,#k do results[#results+1]=k[l]end end;gg.loadResults(results)end;function edit_hex(m)if m==nil then _error("When using edit_hex, supply a hex value to edit to")end;m=m:gsub("%s+","")if _letter(m,1)~="h"then m="h"..m end;if m=="h"then _error("Edit hex is blank")end;local n=#m-1;if n%2~=0 then _error("Invalid edit hex")end;local h=n/2;load_hex(h)gg.getResults(gg.getResultsCount())gg.editAll(m,gg.TYPE_BYTE)end;function load_offset()local o={}local j=search_and_get_function_addresses()ranges=gg.getRangesList(LIB_NAME)if ranges=={}then _error("Failed to find lib '"..LIB_NAME.."'. Is the game running?")end;lib_start=ranges[1]["start"]for f=1,#j do o[#o+1]=j[f]-lib_start end;return o end
